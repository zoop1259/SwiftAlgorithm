import UIKit

/*
 DP란 다이나믹 프로그래밍이다 (기억하기 알고리즘 또는 기억하며풀기 로 생각하면 좋다.)
 문제를 구분하는 방법... 우선 경우의수가 무수히 많을때, 
 왜 사용하는가? 무수히 중복된 계산들을 스킵하여 시간복잡도를 개선하기 위해 사용한다.
 
     [7]
    [3,8]
   [8,1,0]
  [2,7,4,4]
 [4,5,2,6,5]
 
 예를들어 위처럼 생긴 삼각형이 있다고 생각하자. 모든 연산을 통해 최대값을 구하는 것인데.
 DFS같이 재귀함수로하면 (예를들어: 7+3+8+2+4 , 7+3+8+2+5 이런식으로 트리구조로 들어간다고 생각해보자)
 그러면 저렇게 작은 삼각형은 괜찮지만 500줄이상 늘어나버리는 삼각형에는 답이 없이 오래걸리것이다.
 그래서 중복되는 계산을 없애고자 하는것인데.
 
 보기쉽게 이렇게 바꿔보자. 그리고 n*n의 배열을 만들어준다.
 [7]                [0,0,0,0,0]
 [3,8]              [0,0,0,0,0]
 [8,1,0]            [0,0,0,0,0]
 [2,7,4,4]          [0,0,0,0,0]
 [4,5,2,6,5]        [0,0,0,0,0]
 
 그리고나서 하나씩 더한값을 배열에 집어넣는것이다. 바로밑 좌우2개만 계산하는 이유는 문제가 이진트리형태로 되어있기 때문이다.
 [7,0,0,0,0]
 [10,15,0,0,0]
 이제 3번쨰줄부터 중요한데. 우선 배열이 0이라면 처음값을 그냥 집어넣고. 0이 아니라면 큰값일때 배열에 넣는다.
 우선 0이기 때문에 10+8의 값을 넣어준다
 [18,0,0,0,0]
 그리고 10+1 을 해보지만 18보다 작기때문에 넘어간다.
 그리고 0이기 때문에 15+1을 해준다.
 [18,16,0,0,0]
 그리고 15+0이지만 역시 16보다 작기때문에 넘어간다.
 그리고 0이기 떄문에 그냥 15값을 넣어준다.
 [18,16,15,0,0]
 4번째줄부터 똑같이 진행하면 된다.
 18+2를 집어넣는다
 [20,0,0,0,0]
 그리고 18+ 7는 25지만 첫째줄은 기본적으로 쭉 연산해준다고 생각하자. DFS에서도 두가지 경우를 주어주면 우선 처음 경우는 쭉 진행한다.
 바로 위의 내용을 토대로 사실상 첫 연산부터 5번쨰까지는
 [7]
 [10]
 [18]
 [20]
 [24]
 이다.
 
 그러므로 18+7은 두번째칸에 삽입된다.
 [20,25,0,0,0]
 그리고 16+7을 해보지만 25보다 작기때문에 패스된다.
 그리고 그리고 16+4를 해서 20을 넣어준다
 [20,25,20,0,0]
 그리고 15+ 4를해보지만 20보다 작기때문에 패스하고
 그다음에 15+4를 해서 넣어준다
 [20,25,20,19,0]
 다음줄도 마찬가지로 계산해보면
 [24,30,27,26,24] 이렇게 된다.
 
 
 */


